#!/usr/bin/env python3

import subprocess
import sys
import time
from argparse import ArgumentParser, REMAINDER
from pathlib import Path
from typing import Generator

suffixes = {
    'KiB': 2 ** 10,
    'MiB': 2 ** 20,
    'GiB': 2 ** 30
}

KiB = suffixes['KiB']
MiB = suffixes['MiB']
GiB = suffixes['GiB']


def determineNumberSuffix(number: float) -> str:
    suffix = None

    if number < MiB:
        suffix = 'KiB'

    elif number >= MiB and number < GiB:
        suffix = 'MiB'

    elif number >= GiB:
        suffix = 'GiB'

    return suffix


def divideNumberAndFormat(number: float) -> tuple:
    suffix = determineNumberSuffix(number)
    number = number / suffixes[suffix]
    return number, suffix


def multiplyNumberAndFormat(number: float, suffix: str) -> tuple:
    number = number * suffixes[suffix]
    return number, suffix


def formatDirectorySize(number: float, blocksize: float, blocks: float) -> float:
    # This is to provide a "du -sh" like output
    stat_size = (blocks * blocksize) / KiB
    size, suffix = divideNumberAndFormat(number)
    real = multiplyNumberAndFormat(size % stat_size, suffix)
    return real


def getFileSize(path: Path) -> int:
    if not path.is_file():
        return None

    size = path.stat().st_size
    return size


def getDirectoryContents(directory: Path) -> Generator:
    if not directory.is_dir():
        return None

    contents = directory.rglob('*')
    return contents


def getDirectorySize(directory: Path) -> int:
    stat = directory.stat()

    blocks = stat.st_blocks
    blocksize = stat.st_blksize

    contents = getDirectoryContents(directory)

    sizes = 0

    for path in contents:
        path_size = getFileSize(path)

        if not path_size:
            continue

        sizes += path_size

    formatted = formatDirectorySize(sizes, blocksize, blocks)

    return formatted


def getPathSize(path: Path) -> int:
    size = 0

    if path.is_dir():
        size = getDirectorySize(path)[0]
    else:
        size = getFileSize(path)

    return size


def getCompression(new_size: float, old_size: float) -> float:
    compression = 100 - ((new_size / old_size) * 100)
    return compression


def getSpeed(size: float, duration: float) -> float:
    speed = size / duration
    return speed


def determineScore(speed: float, compression: float) -> float:
    score = (GiB / speed) / compression
    return score


def runCommand(command: tuple) -> float:
    start = time.perf_counter()
    subprocess.run(command)
    end = time.perf_counter() - start
    return end


def printMessage(message: str) -> int:
    return sys.stderr.write(f'{message}\n')


def formatNumber(number: float) -> str:
    formatted, suffix = divideNumberAndFormat(number)
    string = f'{formatted:.2f} {suffix}'
    return string


def printResults(
    command: tuple,
    input_size: int,
    output_size: int,
    compression: float,
    duration: float,
    speed: float,
    score: float
) -> None:

    printMessage(f'Command: {command}')
    printMessage(f'Input: {input_size}')
    printMessage(f'Output: {output_size}')
    printMessage(f'Compression: {compression}')
    printMessage(f'Duration: {duration}')
    printMessage(f'Speed: {speed}')
    printMessage(f'Score: {score}')


def go(input_path: Path, output_path: Path, args: list) -> None:
    symbols = ('(in)', '(out)')

    if symbols[0] not in args:
        printMessage(f'"{symbols[0]}" MUST be passed!')
        return

    args[args.index(symbols[0])] = str(input_path)

    if symbols[1] in args:
        args[args.index(symbols[1])] = str(output_path)

    input_size = getPathSize(input_path)

    duration = runCommand(args)

    speed = getSpeed(input_size, duration)

    output_size = getPathSize(output_path)

    compression = getCompression(output_size, input_size)

    score = determineScore(speed, compression)

    results = (
        ' '.join(args),
        formatNumber(input_size),
        formatNumber(output_size),
        f'{compression:.2f}%',
        f'{duration:.4f} sec(s)',
        f'{formatNumber(speed)}/s',
        f'{score:.4f}'
    )

    printResults(*results)


def main() -> None:
    parser = ArgumentParser()

    parser.add_argument('-i', nargs=1, metavar='input')
    parser.add_argument('-o', nargs=1, metavar='output')
    parser.add_argument('-args', nargs=REMAINDER)

    args = parser.parse_args()

    if args.i and args.o and args.args:
        go(Path(args.i[0]), Path(args.o[0]), args.args)
    else:
        parser.print_help()


if __name__ == '__main__':
    main()
