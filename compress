#!/usr/bin/env python3

import subprocess
import time
from argparse import ArgumentParser, REMAINDER
from pathlib import Path

verbose = False

KB = 2 << 9
MB = 2 << 19
GB = 2 << 29


def determineNumberSuffix(n):
    suffix = None

    if n >= KB and n < MB:
        suffix = 'KB'

    elif n >= MB and n < GB:
        suffix = 'MB'

    elif n >= GB:
        suffix = 'GB'

    else:
        pass

    return suffix


def formatNumber(n):
    suffix = determineNumberSuffix(n)

    number = None

    if suffix == 'KB':
        number = n / KB

    elif suffix == 'MB':
        number = n / MB

    elif suffix == 'GB':
        number = n / GB

    else:
        pass

    return f'{round(number, 2)} {suffix}'


def getSpeed(size, duration):
    return size / duration


def getCompression(new, old):
    return ((new / old) * 100) - 100


def getFileSize(src):
    return Path(src).stat().st_size


def getPathSize(src):
    src = Path(src)

    size = None

    if src.is_file():
        size = getFileSize(src)

    elif src.is_dir():
        size = sum(getFileSize(x) for x in Path(src).rglob('*'))

    else:
        pass

    return size


def runCommand(args):
    start = time.perf_counter()

    if verbose:
        subprocess.run(args)
    else:
        subprocess.run(
            args,
            stderr=subprocess.STDOUT,
            stdout=subprocess.DEVNULL
        )

    end = time.perf_counter() - start
    return end


def do7zip(src, dst, *args):
    cmd = (
        '7zz',
        'a',
        *args,
        dst,
        src
    )
    return runCommand(cmd)


def doNanoZip(src, dst, *args):
    cmd = (
        'nz',
        'a',
        *args,
        dst,
        src
    )
    return runCommand(cmd)


def doZip(src, dst, *args):
    cmd = (
        'zip',
        *args,
        dst,
        src
    )
    return runCommand(cmd)


def doZpaq(src, dst, *args):
    cmd = (
        'zpaq',
        'a',
        dst,
        src,
        *args
    )
    return runCommand(cmd)


def doBrotli(src, dst, *args):
    cmd = (
        'brotli',
        *args,
        '-o',
        dst,
        src
    )
    return runCommand(cmd)


def doBzip3(src, dst, *args):
    cmd = (
        'bzip3',
        *args,
        src
    )
    return runCommand(cmd)


def doCmix(src, dst, *args):
    cmd = (
        'cmix',
        *args,
        src,
        dst
    )
    return runCommand(cmd)


def doFxz(src, dst, *args):
    cmd = (
        'fxz',
        *args,
        src
    )
    return runCommand(cmd)


def doLizard(src, dst, *args):
    cmd = (
        'lizard',
        *args,
        src,
        dst
    )
    return runCommand(cmd)


def doLrzipNext(src, dst, *args):
    cmd = (
        'lrzip-next',
        *args,
        '-o',
        dst,
        src
    )
    return runCommand(cmd)


def doLZ4(src, dst, *args):
    cmd = (
        'lz4',
        *args,
        src,
        dst
    )
    return runCommand(cmd)


def doLzop(src, dst, *args):
    cmd = (
        'lzop',
        *args,
        '-o',
        dst,
        src
    )
    return runCommand(cmd)


def doPBzip2(src, dst, *args):
    cmd = (
        'pbzip2',
        *args,
        src
    )
    return runCommand(cmd)


def doPigz(src, dst, *args):
    cmd = (
        'pigz',
        *args,
        src
    )
    return runCommand(cmd)


def doPLzip(src, dst, *args):
    cmd = (
        'plzip',
        *args,
        '-o',
        dst,
        src
    )
    return runCommand(cmd)


def doRzip64(src, dst, *args):
    cmd = (
        'rzip64',
        *args,
        '-o',
        dst,
        src
    )
    return runCommand(cmd)


def doZstd(src, dst, *args):
    cmd = (
        'zstd',
        *args,
        '-o',
        dst,
        src
    )
    return runCommand(cmd)


def determineQuality(speed, compression):
    speed = float(speed.split()[0])

    compression = float(compression[:-1])

    return round((speed + compression) / 2, 2)


def go(func, src, dst, toFile, *args):
    in_size = getPathSize(src)
    in_size_str = formatNumber(in_size)

    duration = round(func(src, dst, *args), 4)
    duration_str = f'{duration} sec(s)'

    out_size = getPathSize(dst)
    out_size_str = formatNumber(out_size)

    speed = getSpeed(in_size, duration)
    speed_str = f'{formatNumber(speed)}/s'

    compression = getCompression(out_size, in_size)
    compression_str = f'{round(compression, 2)}%'

    quality = determineQuality(speed_str, compression_str)

    # For now, low quality is bad and high is good

    output = (
        func.__name__,
        *args,
        duration_str,
        compression_str,
        in_size_str,
        out_size_str,
        speed_str,
        str(quality)
    )

    if toFile:
        with open(toFile, 'a') as f:
            f.write(' '.join(output))
    else:
        print(*output)


def getPrograms():
    functions = []

    for name, obj in globals().items():
        if name.startswith('do'):
            functions.append((name, obj))

    return tuple(functions)


def main():
    parser = ArgumentParser()

    parser.add_argument('-i', nargs=1, metavar='input')
    parser.add_argument('-o', nargs=1, metavar='output')
    parser.add_argument('-f', nargs=1, metavar='results')

    parser.add_argument('-v', action='store_true')

    parser.add_argument('-a', nargs=REMAINDER, metavar='args')

    for program, function in getPrograms():
        parser.add_argument(f'-{program}', action='store_true')

    args = vars(parser.parse_args())

    if args['i'] and args['o']:
        selected = None

        for program in args:
            if program.startswith('do'):
                if args[program]:
                    selected = program
                    break

        if not selected:
            parser.print_help()

        else:
            func = None

            for program, function in getPrograms():
                if function.__name__ == selected:
                    func = function
                    break

            if not func:
                raise Exception('Could not find function!')

            if args['v']:
                global verbose
                verbose = True

            if not args['a']:
                if args['f']:
                    go(func, args['i'][0], args['o'][0], args['f'][0])
                else:
                    go(func, args['i'][0], args['o'][0], False)

            else:
                if args['f']:
                    go(func, args['i'][0], args['o'][0], args['f'][0], *args['a'])
                else:
                    go(func, args['i'][0], args['o'][0], False, *args['a'])

    else:
        parser.print_help()


if __name__ == '__main__':
    main()
